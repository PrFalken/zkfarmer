#!/usr/bin/env python

from socket import socket, AF_INET, SOCK_DGRAM
from watchdog.observers import Observer
import zookeeper
import threading
import json
import os
import os.path
import shutil
import logging


def main():
    from zktools.connection import ZkConnection
    from optparse import OptionParser
    from signal import signal, SIGTERM, SIGINT

    parser = OptionParser(usage='usage: %prog [options] <join|export> /path/to/root/zknode /path/to/conf',
                          description='Register the current host as a node of a service defined by a zookeeper node path on ' +
                                      'one side and export the farm node list into a configuration file on the other side. ' +
                                      'Additionnaly, each node can carry its own configuration.')
    parser.add_option('-H', '--host', dest='host', default=os.environ.get('ZKHOST', 'localhost:2181'),
                      help='list of zookeeper hosts:port sperated by commas')
    parser.add_option('-f', '--format', dest='format', type='choice', choices=['json', 'php', 'dir'],
                      help='set the configuration format (supported formats: json, php, dir)')
    parser.add_option('-q', '--quiet', dest='quiet', action='store_true')
    parser.add_option('-v', '--verbose', dest='verbose', action='store_true')

    (options, args) = parser.parse_args()

    if len(args) is not 3:
        parser.error('Missing argument')

    COMMAND = args[0]
    ROOT_NODE_PATH = args[1]
    CONF_PATH = args[2]

    if ROOT_NODE_PATH[0] is not "/":
        parser.error('First argument must be the full path to the zookeeper node to create (eg: /services/db)')

    if options.verbose:
        level = logging.DEBUG
        zookeeper.set_debug_level(zookeeper.LOG_LEVEL_DEBUG)
    elif options.quiet:
        level = logging.WARN
        zookeeper.set_debug_level(zookeeper.LOG_LEVEL_WARN)
    else:
        level = logging.INFO
        zookeeper.set_debug_level(zookeeper.LOG_LEVEL_INFO)

    logging.basicConfig(level=level, format='%(asctime)s %(levelname)s %(message)s')

    if options.format is 'json':
        conf = ConfJSON(CONF_PATH)
    elif options.format is 'php':
        conf = ConfPHP(CONF_PATH)
    elif options.format is 'dir':
        conf = ConfDir(CONF_PATH)
    else:
        if os.path.isdir(CONF_PATH):
            conf = ConfDir(CONF_PATH)
        elif os.path.splitext(CONF_PATH)[1] == '.json':
            conf = ConfJSON(CONF_PATH)
        elif os.path.splitext(CONF_PATH)[1] == '.php':
            conf = ConfPHP(CONF_PATH)
        else:
            parser.error('Unsupported configuration format: %s' % options.format)
            exit(1)

    zkconn = ZkConnection(host=options.host)

    def sighandler(sig, frame):
        zkconn.close()
        exit()

    signal(SIGTERM, sighandler)
    signal(SIGINT, sighandler)

    if COMMAND == 'export':
        ZkFarmExporter(zkconn, conf, ROOT_NODE_PATH)
    elif COMMAND == 'join':
        ZkFarmJoiner(zkconn, conf, ROOT_NODE_PATH)
    else:
        parser.error('Invalid command: %s' % COMMAND)


class ConfBase(object):
    def __init__(self, file_path):
        self.file_path = file_path

    def read(self):
        raise NotImplementedError('%s.read()' % self.__class__.__name__)

    def write(self, obj):
        raise NotImplementedError('%s.write()' % self.__class__.__name__)


class ConfJSON(ConfBase):
    def write(self, obj):
        with open(self.file_path, 'w') as fd:
            json.dump(obj, fd)

    def read(self):
        with open(self.file_path) as fd:
            return json.load(fd.read())


class ConfPHP(ConfBase):
    meta = {'"': '\\"', "\0": "\\\0", "\n": "\\n", "\\": "\\\\"}

    def _quotemeta(self, value):
        return ''.join(self.meta.get(c, c) for c in value)

    def _dump(self, value):
        if type(value) == int:
            return value
        elif type(value) == str or type(value) == unicode:
            return '"%s"' % self._quotemeta(value)
        elif type(value) == dict:
            return 'array(%s)' % ','.join(['"%s" => %s' % (self._quotemeta(key), self._dump(val)) for key, val in value.items()])
        elif type(value) == list:
            return 'array(%s)' % ','.join([self._dump(val) for val in value])
        else:
            raise TypeError('php_dump: cannot serialize value: %s' % type(value))

    def write(self, obj):
        with open(self.file_path, 'w') as fd:
            fd.write('<?php return %s;' % self._dump(obj))


class ConfDir(ConfBase):
    def _parse(self, path):
        struct = {}
        for entry in os.listdir(path):
            entry_path = os.path.join(path, entry)
            if os.path.isdir(entry_path):
                struct[entry] = self._parse(entry_path)
            else:
                with open(entry_path) as fd:
                    struct[entry] = fd.read().strip()
        return struct

    def _dump(self, obj, path):
        if type(obj) != dict:
            raise TypeError('dir_dump: invalid obj type: %s' % type(obj))

        for key, val in obj.items():
            entry_path = os.path.join(path, key)
            if type(val) == str or type(val) == int or type(val) == unicode:
                if os.path.isdir(entry_path):
                    shutil.rmtree(entry_path)
                with open(entry_path, 'w') as fd:
                    fd.write(val)
            elif type(val) == dict:
                if not os.path.isdir(entry_path):
                    try:
                        os.unlink(entry_path)
                    except OSError:
                        pass
                    os.mkdir(entry_path)
                self._dump(val, entry_path)
            else:
                raise TypeError('dir_dump: cannot serialize value: %s' % type(val))

        # Clean vanished entries at this level
        for entry in os.listdir(path):
            if entry not in obj:
                entry_path = os.path.join(path, entry)
                if os.path.isdir(entry_path):
                    shutil.rmtree(entry_path)
                else:
                    os.unlink(entry_path)

    def read(self):
        return self._parse(self.file_path)

    def write(self, obj):
        self._dump(obj, self.file_path)


class ZkFarm(object):
    def __init__(self):
        self.cv = threading.Condition()
        self.handled = False

    def wait(self):
        while True:
            self.handled = False
            self.cv.wait(60)
            if self.handled:
                break

    def notify(self):
        self.handled = True
        self.cv.notify_all()


class ZkFarmExporter(ZkFarm):
    def __init__(self, zkconn, conf, root_node_path):
        super(ZkFarmExporter, self).__init__()
        self.watched_paths = {}

        while True:
            with self.cv:
                node_names = zkconn.get_children(root_node_path, self.get_watcher(root_node_path))
                nodes = {}
                for name in node_names:
                    subnode_path = '%s/%s' % (root_node_path, name)
                    nodes[name] = zkconn.get(subnode_path, self.get_watcher(subnode_path))[0]
                    try:
                        nodes[name] = json.loads(nodes[name])
                    except ValueError:
                        pass
                conf.write(nodes)
                self.wait()

    def watcher(self, handle, type, state, path):
        with self.cv:
            if path in self.watched_paths:
                del self.watched_paths[path]
            self.notify()

    def get_watcher(self, path):
        if path not in self.watched_paths:
            self.watched_paths[path] = True
            return self.watcher


class ZkFarmJoiner(ZkFarm):
    ZOO_OPEN_ACL_UNSAFE = {"perms": 0x1f, "scheme": "world", "id": "anyone"}

    def __init__(self, zkconn, conf, root_node_path):
        super(ZkFarmJoiner, self).__init__()
        self.conf_changed = False
        self.conf_ignore_next = False
        self.node_changed = False
        self.node_ignore_next = False

        node_path = '%s/%s' % (root_node_path, self.myip())

        zkconn.create(node_path, json.dumps(conf.read()), [self.ZOO_OPEN_ACL_UNSAFE], zookeeper.EPHEMERAL)

        observer = Observer()
        observer.schedule(self, path=conf.file_path, recursive=True)
        observer.start()

        zkconn.get(node_path, self.node_watcher)

        while True:
            with self.cv:
                if self.conf_changed and self.node_changed:
                    logging.warn('Got conflict, both ends modified, enforce local')
                if self.conf_changed:
                    if self.conf_ignore_next:
                        self.conf_ignore_next = False
                    else:
                        logging.info('Local conf changed')
                        self.node_ignore_next = True
                        zkconn.set(node_path, json.dumps(conf.read()))
                elif self.node_changed:
                    data = zkconn.get(node_path, self.node_watcher)[0]
                    if self.node_ignore_next:
                        self.node_ignore_next = False
                    else:
                        logging.info('Remote conf changed')
                        self.conf_ignore_next = True
                        conf.write(json.loads(data))
                self.conf_changed = False
                self.node_changed = False
                self.wait()

    def dispatch(self, event):
        with self.cv:
            self.conf_changed = True
            self.notify()

    def node_watcher(self, handle, type, state, path):
        with self.cv:
            self.node_changed = True
            self.notify()

    def myip(self):
        # Try to find default IP
        ip = None
        s = socket(AF_INET, SOCK_DGRAM)
        try:
            s.connect(('239.255.0.0', 9))
            ip = s.getsockname()[0]
        except socket.error:
            logging.error("Cannot determine host IP")
            exit(1)
        finally:
            del s
        return ip


if __name__ == "__main__":
    main()
